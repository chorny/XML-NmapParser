.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::NmapParser 3"
.TH XML::NmapParser 3 "2016-11-12" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NmapParser \- parse nmap scan data with perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::NmapParser;
\&  my $parser = NmapParser\->new();
\&  
\&  my $parsedFile = $parser\->parse(<NMAP XML file>);
\&  
\&  my $ScannedIPs = $parser\->scanned();
\&  my $LiveHosts = $parser\->live();
\&  
\&  my @IPs = $parser\->get_ips();
\&  
\&  my $host = $parser\->get_host($ip);
\&    # NmapParser::Host object
\&
\&  my @HostScripts = $host\->hostscripts(); 
\&        # returns an array of NmapParser::Host::Script objects
\&   
\&  my $service = $host\->tcp_service(<PORT>);
\&    # NmapParser::Host::Service object
\&    
\&  my @PortScripts = $host_portscripts(<PORT>);   
\&    # returns an array of NmapParser::Host::Script objects
\&    
\&  my @OS = $host\->os_sig();
\&    # returns an array of NmapParser::Host::OS objects
.Ve
.PP
\&\fIFor a full listing of methods see the documentation corresponding to each object.\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A perl module to \s-1JUST\s0 parse nmap \s-1XML\s0 data output.
.PP
It is a fork of the Nmap-Parser minus the ability to do any scannings. It 
maintains all the calls of the other module along with adding some additional 
calls. It also adds a new method for accessing both host script and port 
script results. It also removes the Nmap::Parser::Session object in favor 
of making those default methods fpr the parsed object.
.PP
current code can be found at <http://github.com/littleurl/XML\-NmapParser/>
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This module has an internal framework to make it easy to retrieve the desired information of a scan.
Every nmap scan is based on two main sections of informations: the scan session, and the scan information of all hosts.
The session information will be stored as a Nmap::Parser::Session object. This object will contain its own methods
to obtain the desired information. The same is true for any hosts that were scanned using the Nmap::Parser::Host object.
There are two sub objects under Nmap::Parser::Host. One is the Nmap::Parser::Host::Service object which will be used to obtain
information of a given service running on a given port. The second is the Nmap::Parser::Host::OS object which contains the
operating system signature information (\s-1OS\s0 guessed names, classes, osfamily..etc).
.PP
.Vb 10
\&  Nmap::Parser                         \-\- Core parser
\&     |  
\&     +\-\-Nmap::Parser::Host             \-\- General host information
\&     |  |
\&     |  |\-Nmap::Parser::Host::Service  \-\- Port service information
\&     |  |
\&     |  |\-Nmap::Parser::Host::OS       \-\- Operating system signature information
\&     |  |
\&     |  |\-Nmap::Parser::Host::Service  \-\- Port service information
\&     |  |
\&     |  |\-Nmap::Parser::Host::Script   \-\- any NSE script data for host or port based scripts
\&     |  |
\&     |  |\-Nmap::Parser::Host::TraceHop \-\- any traceroute data for hosts scanned
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "NmapParser"
.IX Subsection "NmapParser"
The main idea behind the core module is, you will first parse the information
and then extract data. Therefore, all parse*() methods should be executed before
any get_*() methods.
.IP "\fBparse($xml_file)\fR" 4
.IX Item "parse($xml_file)"
Parses the nmap scan data in \f(CW$xml_file\fR. This file can be generated from an nmap
scan by using the '\-oX filename.xml' option with nmap. If you get an error or your program dies due to parsing, please check that the
xml information is compliant. The file is closed no matter how \f(CW\*(C`parsefile()\*(C'\fR returns.
.IP "\fBget_host($ip_addr)\fR" 4
.IX Item "get_host($ip_addr)"
Obtains the Nmap::Parser::Host object for the given \f(CW$ip_addr\fR.
.IP "\fB\f(BIget_ips()\fB\fR" 4
.IX Item "get_ips()"
.PD 0
.IP "\fBget_ips($status,$type)\fR" 4
.IX Item "get_ips($status,$type)"
.PD
Returns the list of \s-1IP\s0 addresses that were scanned in this nmap session. They are
sorted using addr_sort. If the optional status is given, it will only return
those \s-1IP\s0 addresses that match that status. The status can be any of the
following: \f(CW\*(C`(up|down|unknown|skipped)\*(C'\fR. And the type can be either \f(CW\*(C`(ipv4|ipv6)\*(C'\fR.
.IP "\fB\f(BIlive()\fB\fR" 4
.IX Item "live()"
Returns the number of hosts identified as live by the scan
.IP "\fB\f(BIdown()\fB\fR" 4
.IX Item "down()"
Returns the number of hosts identified as down by the scan
.IP "\fB\f(BIscanned()\fB\fR" 4
.IX Item "scanned()"
Returns the number of hosts scanned
.IP "\fB\f(BIget_address()\fB\fR" 4
.IX Item "get_address()"
.PD 0
.IP "\fB\f(BIget_host()\fB\fR" 4
.IX Item "get_host()"
.IP "\fB\f(BIfinish_time()\fB\fR" 4
.IX Item "finish_time()"
.PD
Returns the numeric time that the nmap scan finished.
.IP "\fB\f(BInmap_version()\fB\fR" 4
.IX Item "nmap_version()"
Returns the version of nmap used for the scan.
.IP "\fB\f(BInumservices()\fB\fR" 4
.IX Item "numservices()"
.PD 0
.IP "\fBnumservices($type)\fR" 4
.IX Item "numservices($type)"
.PD
If numservices is called without argument, it returns the total number of services
that were scanned for all types. If \f(CW$type\fR is given, it returns the number of services
for that given scan type. See \fIscan_types()\fR for more info.
.IP "\fB\f(BIscan_args()\fB\fR" 4
.IX Item "scan_args()"
Returns a string which contains the nmap executed command line used to run the
scan.
.IP "\fBscan_type_proto($type)\fR" 4
.IX Item "scan_type_proto($type)"
Returns the protocol type of the given scan type (provided by \f(CW$type\fR). See \fIscan_types()\fR for
more info.
.IP "\fB\f(BIscan_types()\fB\fR" 4
.IX Item "scan_types()"
Returns the list of scan types that were performed. It can be any of the following:
\&\f(CW\*(C`(syn|ack|bounce|connect|null|xmas|window|maimon|fin|udp|ipproto)\*(C'\fR.
.IP "\fB\f(BIstart_str()\fB\fR" 4
.IX Item "start_str()"
Returns the human readable format of the start time.
.IP "\fB\f(BIstart_time()\fB\fR" 4
.IX Item "start_time()"
Returns the numeric form of the time the nmap scan started.
.IP "\fB\f(BItime_str()\fB\fR" 4
.IX Item "time_str()"
Returns the human readable format of the finish time.
.IP "\fB\f(BIxml_version()\fB\fR" 4
.IX Item "xml_version()"
Returns the version of nmap xml file.
.SS "Nmap::Parser::Host"
.IX Subsection "Nmap::Parser::Host"
This object represents the information collected from a scanned host.
.IP "\fB\f(BIstatus()\fB\fR" 4
.IX Item "status()"
Returns the state of the host. It is usually one of these
\&\f(CW\*(C`(up|down|unknown|skipped)\*(C'\fR.
.IP "\fB\f(BIaddr()\fB\fR" 4
.IX Item "addr()"
Returns the main \s-1IP\s0 address of the host. This is usually the IPv4 address. If
there is no IPv4 address, the IPv6 is returned (hopefully there is one).
.IP "\fB\f(BIaddrtype()\fB\fR" 4
.IX Item "addrtype()"
Returns the address type of the address given by \fIaddr()\fR .
.IP "\fB\f(BIall_hostnames()\fB\fR" 4
.IX Item "all_hostnames()"
Returns a list of all hostnames found for the given host.
.IP "\fB\f(BIextraports_count()\fB\fR" 4
.IX Item "extraports_count()"
Returns the number of extraports found.
.IP "\fB\f(BIextraports_state()\fB\fR" 4
.IX Item "extraports_state()"
Returns the state of all the extraports found.
.IP "\fB\f(BIhostname()\fB\fR" 4
.IX Item "hostname()"
.PD 0
.IP "\fBhostname($index)\fR" 4
.IX Item "hostname($index)"
.PD
As a basic call, \fIhostname()\fR returns the first hostname obtained for the given
host. If there exists more than one hostname, you can provide a number, which
is used as the location in the array. The index starts at 0;
.Sp
.Vb 4
\& #in the case that there are only 2 hostnames
\& hostname() eq hostname(0);
\& hostname(1); #second hostname found
\& hostname(400) eq hostname(1) #nothing at 400; return the name at the last index
.Ve
.IP "\fB\f(BIipv4_addr()\fB\fR" 4
.IX Item "ipv4_addr()"
Explicitly return the IPv4 address.
.IP "\fB\f(BIipv6_addr()\fB\fR" 4
.IX Item "ipv6_addr()"
Explicitly return the IPv6 address.
.IP "\fB\f(BImac_addr()\fB\fR" 4
.IX Item "mac_addr()"
Explicitly return the \s-1MAC\s0 address.
.IP "\fB\f(BImac_vendor()\fB\fR" 4
.IX Item "mac_vendor()"
Return the vendor information of the \s-1MAC.\s0
.IP "\fB\f(BIdistance()\fB\fR" 4
.IX Item "distance()"
Return the distance (in hops) of the target machine from the machine that performed the scan.
.IP "\fB\f(BItrace_error()\fB\fR" 4
.IX Item "trace_error()"
Returns a true value (usually a meaningful error message) if the traceroute was
performed but could not reach the destination. In this case \f(CW\*(C`all_trace_hops()\*(C'\fR
contains only the part of the path that could be determined.
.IP "\fB\f(BIall_trace_hops()\fB\fR" 4
.IX Item "all_trace_hops()"
Returns an array of Nmap::Parser::Host::TraceHop objects representing the path
to the target host. This array may be empty if Nmap did not perform the
traceroute for some reason (same network, for example).
.Sp
Some hops may be missing if Nmap could not figure out information about them.
In this case there is a gap between the \f(CW\*(C`ttl()\*(C'\fR values of consecutive returned
hops. See also \f(CW\*(C`trace_error()\*(C'\fR.
.IP "\fB\f(BItrace_proto()\fB\fR" 4
.IX Item "trace_proto()"
Returns the name of the protocol used to perform the traceroute.
.IP "\fB\f(BItrace_port()\fB\fR" 4
.IX Item "trace_port()"
Returns the port used to perform the traceroute.
.IP "\fB\f(BIos_sig()\fB\fR" 4
.IX Item "os_sig()"
Returns an Nmap::Parser::Host::OS object that can be used to obtain all the
Operating System signature (fingerprint) information. See Nmap::Parser::Host::OS
for more details.
.Sp
.Vb 3
\& $os = $host\->os_sig;
\& $os\->name;
\& $os\->osfamily;
.Ve
.IP "\fB\f(BItcpsequence_class()\fB\fR" 4
.IX Item "tcpsequence_class()"
.PD 0
.IP "\fB\f(BItcpsequence_index()\fB\fR" 4
.IX Item "tcpsequence_index()"
.IP "\fB\f(BItcpsequence_values()\fB\fR" 4
.IX Item "tcpsequence_values()"
.PD
Returns the class, index and values information respectively of the tcp sequence.
.IP "\fB\f(BIipidsequence_class()\fB\fR" 4
.IX Item "ipidsequence_class()"
.PD 0
.IP "\fB\f(BIipidsequence_values()\fB\fR" 4
.IX Item "ipidsequence_values()"
.PD
Returns the class and values information respectively of the ipid sequence.
.IP "\fB\f(BItcptssequence_class()\fB\fR" 4
.IX Item "tcptssequence_class()"
.PD 0
.IP "\fB\f(BItcptssequence_values()\fB\fR" 4
.IX Item "tcptssequence_values()"
.PD
Returns the class and values information respectively of the tcpts sequence.
.IP "\fB\f(BIuptime_lastboot()\fB\fR" 4
.IX Item "uptime_lastboot()"
Returns the human readable format of the timestamp of when the host had last
rebooted.
.IP "\fB\f(BIuptime_seconds()\fB\fR" 4
.IX Item "uptime_seconds()"
Returns the number of seconds that have passed since the host's last boot from
when the scan was performed.
.IP "\fB\f(BIhostscripts()\fB\fR" 4
.IX Item "hostscripts()"
.PD 0
.IP "\fBhostscripts($name)\fR" 4
.IX Item "hostscripts($name)"
.PD
A basic call to \fIhostscripts()\fR returns a list of the names of the host scripts
run. If \f(CW$name\fR is given, it returns the text output of the
a reference to a hash with \*(L"output\*(R" and \*(L"content\*(R" keys for the
script with that name, or undef if that script was not run.
The value of the \*(L"output\*(R" key is the text output of the script. The value of the
\&\*(L"content\*(R" key is a data structure based on the \s-1XML\s0 output of the \s-1NSE\s0 script.
.IP "\fB\f(BItcp_ports()\fB\fR" 4
.IX Item "tcp_ports()"
.PD 0
.IP "\fB\f(BIudp_ports()\fB\fR" 4
.IX Item "udp_ports()"
.PD
Returns the sorted list of TCP|UDP ports respectively that were scanned on this host. Optionally
a string argument can be given to these functions to filter the list.
.Sp
.Vb 2
\& $host\->tcp_ports(\*(Aqopen\*(Aq) #returns all only \*(Aqopen\*(Aq ports (even \*(Aqopen|filtered\*(Aq)
\& $host\->udp_ports(\*(Aqopen|filtered\*(Aq); #matches exactly ports with \*(Aqopen|filtered\*(Aq
.Ve
.Sp
\&\fINote that if a port state is set to 'open|filtered' (or any combination), it will
be counted as an 'open' port as well as a 'filtered' one.\fR
.IP "\fB\f(BItcp_port_count()\fB\fR" 4
.IX Item "tcp_port_count()"
.PD 0
.IP "\fB\f(BIudp_port_count()\fB\fR" 4
.IX Item "udp_port_count()"
.PD
Returns the total of TCP|UDP ports scanned respectively.
.IP "\fBtcp_del_ports($portid, [$portid, ...])\fR" 4
.IX Item "tcp_del_ports($portid, [$portid, ...])"
.PD 0
.ie n .IP "\fBudp_del_ports($portid, [ \fB$portid\fB, ...])\fR" 4
.el .IP "\fBudp_del_ports($portid, [ \f(CB$portid\fB, ...])\fR" 4
.IX Item "udp_del_ports($portid, [ $portid, ...])"
.PD
Deletes the current \f(CW$portid\fR from the list of ports for given protocol.
.IP "\fBtcp_port_state($portid)\fR" 4
.IX Item "tcp_port_state($portid)"
.PD 0
.IP "\fBudp_port_state($portid)\fR" 4
.IX Item "udp_port_state($portid)"
.PD
Returns the state of the given port, provided by the port number in \f(CW$portid\fR.
.IP "\fB\f(BItcp_open_ports()\fB\fR" 4
.IX Item "tcp_open_ports()"
.PD 0
.IP "\fB\f(BIudp_open_ports()\fB\fR" 4
.IX Item "udp_open_ports()"
.PD
Returns the list of open TCP|UDP ports respectively. Note that if a port state is
for example, 'open|filtered', it will appear on this list as well.
.IP "\fB\f(BItcp_filtered_ports()\fB\fR" 4
.IX Item "tcp_filtered_ports()"
.PD 0
.IP "\fB\f(BIudp_filtered_ports()\fB\fR" 4
.IX Item "udp_filtered_ports()"
.PD
Returns the list of filtered TCP|UDP ports respectively. Note that if a port state is
for example, 'open|filtered', it will appear on this list as well.
.IP "\fB\f(BItcp_closed_ports()\fB\fR" 4
.IX Item "tcp_closed_ports()"
.PD 0
.IP "\fB\f(BIudp_closed_ports()\fB\fR" 4
.IX Item "udp_closed_ports()"
.PD
Returns the list of closed TCP|UDP ports respectively. Note that if a port state is
for example, 'closed|filtered', it will appear on this list as well.
.IP "\fBtcp_service($portid)\fR" 4
.IX Item "tcp_service($portid)"
.PD 0
.IP "\fBudp_service($portid)\fR" 4
.IX Item "udp_service($portid)"
.PD
Returns the Nmap::Parser::Host::Service object of a given service running on port,
provided by \f(CW$portid\fR. See Nmap::Parser::Host::Service for more info.
.Sp
.Vb 3
\& $svc = $host\->tcp_service(80);
\& $svc\->name;
\& $svc\->proto;
.Ve
.PP
\fINmap::Parser::Host::Service\fR
.IX Subsection "Nmap::Parser::Host::Service"
.PP
This object represents the service running on a given port in a given host. This
object is obtained by using the tcp_service($portid) or udp_service($portid) method from the
Nmap::Parser::Host object. If a portid is given that does not exist on the given
host, these functions will still return an object (so your script doesn't die).
Its good to use \fItcp_ports()\fR or \fIudp_ports()\fR to see what ports were collected.
.IP "\fB\f(BIconfidence()\fB\fR" 4
.IX Item "confidence()"
Returns the confidence level in service detection.
.IP "\fB\f(BIextrainfo()\fB\fR" 4
.IX Item "extrainfo()"
Returns any additional information nmap knows about the service.
.IP "\fB\f(BImethod()\fB\fR" 4
.IX Item "method()"
Returns the detection method.
.IP "\fB\f(BIname()\fB\fR" 4
.IX Item "name()"
Returns the service name.
.IP "\fB\f(BIowner()\fB\fR" 4
.IX Item "owner()"
Returns the process owner of the given service. (If available)
.IP "\fB\f(BIport()\fB\fR" 4
.IX Item "port()"
Returns the port number where the service is running on.
.IP "\fB\f(BIproduct()\fB\fR" 4
.IX Item "product()"
Returns the product information of the service.
.IP "\fB\f(BIproto()\fB\fR" 4
.IX Item "proto()"
Returns the protocol type of the service.
.IP "\fB\f(BIrpcnum()\fB\fR" 4
.IX Item "rpcnum()"
Returns the \s-1RPC\s0 number.
.IP "\fB\f(BItunnel()\fB\fR" 4
.IX Item "tunnel()"
Returns the tunnel value. (If available)
.IP "\fB\f(BIfingerprint()\fB\fR" 4
.IX Item "fingerprint()"
Returns the service fingerprint. (If available)
.IP "\fB\f(BIversion()\fB\fR" 4
.IX Item "version()"
Returns the version of the given product of the running service.
.IP "\fB\f(BIscripts()\fB\fR" 4
.IX Item "scripts()"
.PD 0
.IP "\fBscripts($name)\fR" 4
.IX Item "scripts($name)"
.PD
A basic call to \fIscripts()\fR returns a list of the names of the \s-1NSE\s0 scripts
run for this port. If \f(CW$name\fR is given, it returns
a reference to a hash with \*(L"output\*(R" and \*(L"content\*(R" keys for the
script with that name, or undef if that script was not run.
The value of the \*(L"output\*(R" key is the text output of the script. The value of the
\&\*(L"content\*(R" key is a data structure based on the \s-1XML\s0 output of the \s-1NSE\s0 script.
.PP
\fINmap::Parser::Host::OS\fR
.IX Subsection "Nmap::Parser::Host::OS"
.PP
This object represents the Operating System signature (fingerprint) information
of the given host. This object is obtained from an Nmap::Parser::Host object
using the \f(CW\*(C`os_sig()\*(C'\fR method. One important thing to note is that the order of \s-1OS\s0
names and classes are sorted by \fB\s-1DECREASING ACCURACY\s0\fR. This is more important than
alphabetical ordering. Therefore, a basic call
to any of these functions will return the record with the highest accuracy.
(Which is probably the one you want anyways).
.IP "\fB\f(BIall_names()\fB\fR" 4
.IX Item "all_names()"
Returns the list of all the guessed \s-1OS\s0 names for the given host.
.IP "\fB\f(BIclass_accuracy()\fB\fR" 4
.IX Item "class_accuracy()"
.PD 0
.IP "\fBclass_accuracy($index)\fR" 4
.IX Item "class_accuracy($index)"
.PD
A basic call to \fIclass_accuracy()\fR returns the osclass accuracy of the first record.
If \f(CW$index\fR is given, it returns the osclass accuracy for the given record. The
index starts at 0.
.IP "\fB\f(BIclass_count()\fB\fR" 4
.IX Item "class_count()"
Returns the total number of \s-1OS\s0 class records obtained from the nmap scan.
.IP "\fB\f(BIname()\fB\fR" 4
.IX Item "name()"
.PD 0
.IP "\fBname($index)\fR" 4
.IX Item "name($index)"
.IP "\fB\f(BInames()\fB\fR" 4
.IX Item "names()"
.IP "\fBnames($index)\fR" 4
.IX Item "names($index)"
.PD
A basic call to \fIname()\fR returns the \s-1OS\s0 name of the first record which is the name
with the highest accuracy. If \f(CW$index\fR is given, it returns the name for the given record. The
index starts at 0.
.IP "\fB\f(BIname_accuracy()\fB\fR" 4
.IX Item "name_accuracy()"
.PD 0
.IP "\fBname_accuracy($index)\fR" 4
.IX Item "name_accuracy($index)"
.PD
A basic call to \fIname_accuracy()\fR returns the \s-1OS\s0 name accuracy of the first record. If \f(CW$index\fR is given, it returns the name for the given record. The
index starts at 0.
.IP "\fB\f(BIname_count()\fB\fR" 4
.IX Item "name_count()"
Returns the total number of \s-1OS\s0 names (records) for the given host.
.IP "\fB\f(BIosfamily()\fB\fR" 4
.IX Item "osfamily()"
.PD 0
.IP "\fBosfamily($index)\fR" 4
.IX Item "osfamily($index)"
.PD
A basic call to \fIosfamily()\fR returns the \s-1OS\s0 family information of the first record.
If \f(CW$index\fR is given, it returns the \s-1OS\s0 family information for the given record. The
index starts at 0.
.IP "\fB\f(BIosgen()\fB\fR" 4
.IX Item "osgen()"
.PD 0
.IP "\fBosgen($index)\fR" 4
.IX Item "osgen($index)"
.PD
A basic call to \fIosgen()\fR returns the \s-1OS\s0 generation information of the first record.
If \f(CW$index\fR is given, it returns the \s-1OS\s0 generation information for the given record. The
index starts at 0.
.IP "\fB\f(BIportused_closed()\fB\fR" 4
.IX Item "portused_closed()"
Returns the closed port number used to help identify the \s-1OS\s0 signatures. This might not
be available for all hosts.
.IP "\fB\f(BIportused_open()\fB\fR" 4
.IX Item "portused_open()"
Returns the open port number used to help identify the \s-1OS\s0 signatures. This might
not be available for all hosts.
.IP "\fB\f(BIos_fingerprint()\fB\fR" 4
.IX Item "os_fingerprint()"
Returns the \s-1OS\s0 fingerprint used to help identify the \s-1OS\s0 signatures. This might not be available for all hosts.
.IP "\fB\f(BItype()\fB\fR" 4
.IX Item "type()"
.PD 0
.IP "\fBtype($index)\fR" 4
.IX Item "type($index)"
.PD
A basic call to \fItype()\fR returns the \s-1OS\s0 type information of the first record.
If \f(CW$index\fR is given, it returns the \s-1OS\s0 type information for the given record. The
index starts at 0.
.IP "\fB\f(BIvendor()\fB\fR" 4
.IX Item "vendor()"
.PD 0
.IP "\fBvendor($index)\fR" 4
.IX Item "vendor($index)"
.PD
A basic call to \fIvendor()\fR returns the \s-1OS\s0 vendor information of the first record.
If \f(CW$index\fR is given, it returns the \s-1OS\s0 vendor information for the given record. The
index starts at 0.
.PP
\fINmap::Parser::Host::TraceHop\fR
.IX Subsection "Nmap::Parser::Host::TraceHop"
.PP
This object represents a router on the \s-1IP\s0 path towards the destination or the
destination itself. This is similar to what the \f(CW\*(C`traceroute\*(C'\fR command outputs.
.PP
Nmap::Parser::Host::TraceHop objects are obtained through the
\&\f(CW\*(C`all_trace_hops()\*(C'\fR and \f(CW\*(C`trace_hop()\*(C'\fR Nmap::Parser::Host methods.
.IP "\fB\f(BIttl()\fB\fR" 4
.IX Item "ttl()"
The Time To Live is the network distance of this hop.
.IP "\fB\f(BIrtt()\fB\fR" 4
.IX Item "rtt()"
The Round Trip Time is roughly equivalent to the \*(L"ping\*(R" time towards this hop.
It is not always available (in which case it will be undef).
.IP "\fB\f(BIipaddr()\fB\fR" 4
.IX Item "ipaddr()"
The known \s-1IP\s0 address of this hop.
.IP "\fB\f(BIhost()\fB\fR" 4
.IX Item "host()"
The host name of this hop, if known.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& use Nmap::Parser;
\&
\& my $np = new Nmap::Parser;
\& my @hosts = @ARGV; #get hosts from cmd line
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Discussion Forum"
.IX Subsection "Discussion Forum"
If you have questions about how to use the module please contact the author below.
.SS "Bug Reports, Enhancements, Merge Requests"
.IX Subsection "Bug Reports, Enhancements, Merge Requests"
Please submit any bugs or feature requests to:
<https://github.com/littleurl/XML\-NmapParser/issues>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
nmap, XML::LibXML
.PP
The nmap security scanner homepage can be found at: <http://www.insecure.org/nmap/>.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul M Johnson <pjohnson21211@gmail.com>
but credit to the original author of Nmap-Parser is Anthony Persaud L <http://modernistik.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
1;
